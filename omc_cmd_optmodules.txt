The --preOptModules flag sets the optimization modules which are used before the
matching and index reduction in the back end. These modules are specified as a comma-separated list.

The modules used by default are:
--preOptModules=normalInlineFunction,evaluateParameters,simplifyIfEquations,expandDerOperator,clockPartitioning,findStateOrder,replaceEdgeChange,inlineArrayEqn,removeEqualRHS,removeSimpleEquations,comSubExp,resolveLoops,evalFunc,encapsulateWhenConditions

The valid modules are:
 * introduceOutputAliases     Introduces aliases for top-level outputs.
 * clockPartitioning          Does the clock partitioning.
 * collapseArrayExpressions   Simplifies {x[1],x[2],x[3]} → x for arrays of
                                whole variable references (simplifies code
                                generation).
 * comSubExp                  Introduces alias assignments for variables which
                                are assigned to simple terms i.e. a = b/c; d =
                                b/c; --> a=d
 * dumpDAE                    dumps the DAE representation of the current
                                transformation state
 * dumpDAEXML                 dumps the DAE as xml representation of the current
                                transformation state
 * encapsulateWhenConditions  This module replaces each when condition with a
                                boolean variable.
 * evalFunc                   evaluates functions partially
 * evaluateParameters         Evaluates parameters with annotation(Evaluate=tru-
                                e). Use '--evaluateFinalParameters=true' or
                                '--evaluateProtectedParameters=true' to specify
                                additional parameters to be evaluated. Use
                                '--replaceEvaluatedParameters=true' if the
                                evaluated parameters should be replaced in the
                                DAE. To evaluate all parameters in the Frontend
                                use -d=evaluateAllParameters.
 * expandDerOperator          Expands der(expr) using Derive.differentiteExpTim-
                                e.
 * findStateOrder             Sets derivative information to states.
 * inlineArrayEqn             This module expands all array equations to scalar
                                equations.
 * normalInlineFunction       Perform function inlining for function with
                                annotation Inline=true.
 * inputDerivativesForDynOpt  Allowed derivatives of inputs in dyn.
                                optimization.
 * introduceDerAlias          Adds for every der-call an alias equation e.g. dx
                                = der(x).
 * removeEqualRHS             Detects equal expressions of the form a=<exp> and
                                b=<exp> and substitutes them to get speed up.
 * removeProtectedParameters  Replace all parameters with protected=true in the
                                system.
 * removeSimpleEquations      Performs alias elimination and removes constant
                                variables from the DAE, replacing all
                                occurrences of the old variable reference with
                                the new value (constants) or variable reference
                                (alias elimination).
 * removeUnusedParameter      Strips all parameter not present in the equations
                                from the system.
 * removeUnusedVariables      Strips all variables not present in the equations
                                from the system.
 * removeVerySimpleEquations  [Experimental] Like removeSimpleEquations, but
                                less thorough. Note that this always uses the
                                experimental new alias elimination,
                                --removeSimpleEquations=new, which makes it
                                unstable. In particular, MultiBody systems fail
                                to translate correctly. It can be used for
                                simple (but large) systems of equations.
 * replaceEdgeChange          Replace edge(b) = b and not pre(b) and change(b) =
                                v <> pre(v).
 * residualForm               Transforms simple equations x=y to zero-sum
                                equations 0=y-x.
 * resolveLoops               resolves linear equations in loops
 * simplifyAllExpressions     Does simplifications on all expressions.
 * simplifyIfEquations        Tries to simplify if equations by use of
                                information from evaluated parameters.
 * sortEqnsVars               Heuristic sorting for equations and variables.
 * unitChecking               Does advanced unit checking which consists of two
                                parts: 1. calculation of unspecified unit
                                information for variables; 2. consistency check
                                for all equations based on unit information.
                                Please note: This module is still experimental.
 * wrapFunctionCalls          This module introduces variables for each function
                                call and substitutes all these calls with the
                                newly introduced variables.

The --matchingAlgorithm sets the method that is used for the matching algorithm, after the pre optimization modules.

The method used by default is:
--matchingAlgorithm=PFPlusExt

The valid methods are:
 * BFSB                       Breadth First Search based algorithm.
 * DFSB                       Depth First Search based algorithm.
 * MC21A                      Depth First Search based algorithm with look ahead
                                feature.
 * PF                         Depth First Search based algorithm with look ahead
                                feature.
 * PFPlus                     Depth First Search based algorithm with look ahead
                                feature and fair row traversal.
 * HK                         Combined BFS and DFS algorithm.
 * HKDW                       Combined BFS and DFS algorithm.
 * ABMP                       Combined BFS and DFS algorithm.
 * PR                         Matching algorithm using push relabel mechanism.
 * DFSBExt                    Depth First Search based Algorithm external c
                                implementation.
 * BFSBExt                    Breadth First Search based Algorithm external c
                                implementation.
 * MC21AExt                   Depth First Search based Algorithm with look ahead
                                feature external c implementation.
 * PFExt                      Depth First Search based Algorithm with look ahead
                                feature external c implementation.
 * PFPlusExt                  Depth First Search based Algorithm with look ahead
                                feature and fair row traversal external c
                                implementation.
 * HKExt                      Combined BFS and DFS algorithm external c
                                implementation.
 * HKDWExt                    Combined BFS and DFS algorithm external c
                                implementation.
 * ABMPExt                    Combined BFS and DFS algorithm external c
                                implementation.
 * PRExt                      Matching algorithm using push relabel mechanism
                                external c implementation.
 * BB                         BBs try.

The --indexReductionMethod sets the method that is used for the index reduction, after the pre optimization modules.

The method used by default is:
--indexReductionMethod=dynamicStateSelection

The valid methods are:
 * none                       Skip index reduction
 * uode                       Use the underlying ODE without the constraints.
 * dynamicStateSelection      Simple index reduction method, select (dynamic)
                                dummy states based on analysis of the system.
 * dummyDerivatives           Simple index reduction method, select (static)
                                dummy states based on heuristic.

The --initOptModules then sets the optimization modules which are used after the index reduction to optimize the system for initialization, specified as a comma-separated list.

The modules used by default are:
--initOptModules=simplifyComplexFunction,tearingSystem,solveSimpleEquations,calculateStrongComponentJacobians,simplifyAllExpressions,collapseArrayExpressions

The valid modules are:
 * calculateStrongComponentJacobians Generates analytical jacobian for torn
                                linear and non-linear strong components. By
                                default linear components and non-linear
                                components with user-defined function calls are
                                skipped. See also debug flags: LSanalyticJacobi-
                                an, NLSanalyticJacobian and forceNLSanalyticJac-
                                obian
 * collapseArrayExpressions   Simplifies {x[1],x[2],x[3]} → x for arrays of
                                whole variable references (simplifies code
                                generation).
 * constantLinearSystem       Evaluates constant linear systems (a*x+b*y=c;
                                d*x+e*y=f; a,b,c,d,e,f are constants) at compile
                                -time.
 * extendDynamicOptimization  Move loops to constraints.
 * generateHomotopyComponents Finds the parts of the DAE that have to be handled
                                by the homotopy solver and creates a strong
                                component out of it.
 * inlineHomotopy             Experimental: Inlines the homotopy expression to
                                allow symbolic simplifications.
 * inputDerivativesUsed       Checks if derivatives of inputs are need to
                                calculate the model.
 * recursiveTearing           inline and repeat tearing
 * reduceDynamicOptimization  Removes equations which are not needed for the
                                calculations of cost and constraints. This
                                module requires -d=reduceDynOpt.
 * replaceHomotopyWithSimplified Replaces the homotopy expression
                                homotopy(actual, simplified) with the simplified
                                part.
 * simplifyAllExpressions     Does simplifications on all expressions.
 * simplifyComplexFunction    Some simplifications on complex functions (complex
                                refers to the internal data structure)
 * simplifyConstraints        Rewrites nonlinear constraints into box
                                constraints if possible. This module requires
                                +gDynOpt.
 * simplifyLoops              Simplifies algebraic loops. This modules requires
                                +simplifyLoops.
 * solveSimpleEquations       Solves simple equations
 * tearingSystem              For method selection use flag tearingMethod.
 * wrapFunctionCalls          This module introduces variables for each function
                                call and substitutes all these calls with the
                                newly introduced variables.

The --postOptModules then sets the optimization modules which are used after the index reduction to optimize the system for simulation, specified as a comma-separated list.

The modules used by default are:
--postOptModules=lateInlineFunction,wrapFunctionCalls,inlineArrayEqn,constantLinearSystem,simplifysemiLinear,removeSimpleEquations,simplifyComplexFunction,solveSimpleEquations,tearingSystem,inputDerivativesUsed,calculateStrongComponentJacobians,calculateStateSetsJacobians,symbolicJacobian,removeConstants,simplifyTimeIndepFuncCalls,simplifyAllExpressions,findZeroCrossings,collapseArrayExpressions

The valid modules are:
 * addScaledVars_states       added var_norm = var/nominal, where var is state
 * addScaledVars_inputs       added var_norm = var/nominal, where var is input
 * addTimeAsState             Experimental feature: this replaces each
                                occurrence of variable time with a new
                                introduced state $time with equation der($time)
                                = 1.0
 * calculateStateSetsJacobians Generates analytical jacobian for dynamic state
                                selection sets.
 * calculateStrongComponentJacobians Generates analytical jacobian for torn
                                linear and non-linear strong components. By
                                default linear components and non-linear
                                components with user-defined function calls are
                                skipped. See also debug flags: LSanalyticJacobi-
                                an, NLSanalyticJacobian and forceNLSanalyticJac-
                                obian
 * collapseArrayExpressions   Simplifies {x[1],x[2],x[3]} → x for arrays of
                                whole variable references (simplifies code
                                generation).
 * constantLinearSystem       Evaluates constant linear systems (a*x+b*y=c;
                                d*x+e*y=f; a,b,c,d,e,f are constants) at compile
                                -time.
 * countOperations            Count the mathematical operations of the system.
 * cseBinary                  Common Sub-expression Elimination
 * dumpComponentsGraphStr     Dumps the assignment graph used to determine
                                strong components to format suitable for
                                Mathematica
 * dumpDAE                    dumps the DAE representation of the current
                                transformation state
 * dumpDAEXML                 dumps the DAE as xml representation of the current
                                transformation state
 * evaluateParameters         Evaluates parameters with annotation(Evaluate=tru-
                                e). Use '--evaluateFinalParameters=true' or
                                '--evaluateProtectedParameters=true' to specify
                                additional parameters to be evaluated. Use
                                '--replaceEvaluatedParameters=true' if the
                                evaluated parameters should be replaced in the
                                DAE. To evaluate all parameters in the Frontend
                                use -d=evaluateAllParameters.
 * extendDynamicOptimization  Move loops to constraints.
 * generateSymbolicLinearization Generates symbolic linearization matrices
                                A,B,C,D for linear model:
                                	\dot{x} = Ax + Bu 
                                	y = Cx +Du
 * generateSymbolicSensitivities Generates symbolic Sensivities matrix, where
                                der(x) is differentiated w.r.t. param.
 * inlineArrayEqn             This module expands all array equations to scalar
                                equations.
 * inputDerivativesUsed       Checks if derivatives of inputs are need to
                                calculate the model.
 * lateInlineFunction         Perform function inlining for function with
                                annotation LateInline=true.
 * partlintornsystem          partitions linear torn systems.
 * recursiveTearing           inline and repeat tearing
 * reduceDynamicOptimization  Removes equations which are not needed for the
                                calculations of cost and constraints. This
                                module requires -d=reduceDynOpt.
 * relaxSystem                relaxation from gausian elemination
 * removeConstants            Remove all constants in the system.
 * removeEqualRHS             Detects equal function calls of the form a=f(b)
                                and c=f(b) and substitutes them to get speed up.
 * removeSimpleEquations      Performs alias elimination and removes constant
                                variables from the DAE, replacing all
                                occurrences of the old variable reference with
                                the new value (constants) or variable reference
                                (alias elimination).
 * removeUnusedParameter      Strips all parameter not present in the equations
                                from the system to get speed up for compilation
                                of target code.
 * removeUnusedVariables      Strips all variables not present in the equations
                                from the system to get speed up for compilation
                                of target code.
 * reshufflePost              Reshuffles algebraic loops.
 * simplifyAllExpressions     Does simplifications on all expressions.
 * simplifyComplexFunction    Some simplifications on complex functions (complex
                                refers to the internal data structure)
 * simplifyConstraints        Rewrites nonlinear constraints into box
                                constraints if possible. This module requires
                                +gDynOpt.
 * simplifyLoops              Simplifies algebraic loops. This modules requires
                                +simplifyLoops.
 * simplifyTimeIndepFuncCalls Simplifies time independent built in function
                                calls like pre(param) -> param, der(param) ->
                                0.0, change(param) -> false, edge(param) ->
                                false.
 * simplifysemiLinear         Simplifies calls to semiLinear.
 * solveLinearSystem          solve linear system with newton step
 * solveSimpleEquations       Solves simple equations
 * symSolver                  Rewrites the ode system for implicit Euler method.
                                This module requires +symSolver.
 * symbolicJacobian           Detects the sparse pattern of the ODE system and
                                calculates also the symbolic Jacobian if flag '-
                                -generateSymbolicJacobian' is enabled.
 * tearingSystem              For method selection use flag tearingMethod.
 * wrapFunctionCalls          This module introduces variables for each function
                                call and substitutes all these calls with the
                                newly introduced variables.

